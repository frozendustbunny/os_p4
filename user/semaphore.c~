
#include "types.h"
#include "user.h"

void sem_init(struct semaphore* sem, int initval)
{
sem->sema_value = 0;
sem->sema_waiters = 0;

mutex_init(&sem->sema_mutex);
cv_init(sem->condvar);

}

void sem_wait(struct semaphore* sem)
{

mutex_lock(&sem->sema_mutex);
while (sem->sema_value == 0){
  sem->sema_waiters++;
  cv_wait(&sem->sema_condvar, &sem->sema_mutex);
  sem->sema_waiters--;
}
sem->sema_value--;


/*
grabbed from linux kern
void
_sema_wait(struct sema *sema, const char *file, int line)
{

	mtx_lock(&sema->sema_mtx);
	while (sema->sema_value == 0) {
		sema->sema_waiters++;
		cv_wait(&sema->sema_cv, &sema->sema_mtx);
		sema->sema_waiters--;
	}
	sema->sema_value--;

	CTR6(KTR_LOCK, "%s(%p) \"%s\" v = %d at %s:%d", __func__, sema,
	    cv_wmesg(&sema->sema_cv), sema->sema_value, file, line);

	mtx_unlock(&sema->sema_mtx);
}


*/
/* grabbed from solaris source code 
#pragma weak _sema_wait = sema_wait
int
sema_wait(sema_t *sp)
{
ASSERT(!curthread->ul_critical || curthread->ul_bindflags);
return (sema_wait_impl(sp, NULL));
}
 
int
sema_reltimedwait(sema_t *sp, const timespec_t *reltime)
{
timespec_t tslocal = *reltime;
 
ASSERT(!curthread->ul_critical || curthread->ul_bindflags);
return (sema_wait_impl(sp, &tslocal));
}
 
int
sema_timedwait(sema_t *sp, const timespec_t *abstime)
{
timespec_t tslocal;
 
ASSERT(!curthread->ul_critical || curthread->ul_bindflags);
abstime_to_reltime(CLOCK_REALTIME, abstime, &tslocal);
return (sema_wait_impl(sp, &tslocal));
}

*/

}

void sem_post(struct semaphore* sem)
{

mutex_lock(&sem->sema_mutex)
sem->sema_value ++;
  if(sem->sema_waiters > 0 && sem->semavalue > 0)
  {
    cv_signal(&sem->sema_cv);
  }
mutex_unlock(&sem->sema_mutex);

}

